{"version":3,"sources":["components/common/MobileOverlayLayout/styles.module.css","components/common/MobileOverlayLayout/OverlaySwitchButton/styles.module.css","components/App/MobileExplorer/OverlayMenu/styles.module.css","utils/gamsUtils.ts","components/common/GamsWidget/DataProvider/index.tsx","components/common/GamsWidget/WidgetDefProvider/index.tsx","components/common/GamsWidget/index.tsx","components/common/MobileOverlayLayout/Overlay/index.tsx","components/common/MobileOverlayLayout/OverlaySwitchButton/index.tsx","components/common/MobileOverlayLayout/index.tsx","components/App/MobileExplorer/OverlayMenu/index.tsx","components/common/BsCheckBox/index.tsx","components/common/BsSelect/index.tsx","@types/enums/classNames.ts","components/common/BsTabs/index.tsx","components/App/MobileExplorer/GeoDataControl/index.tsx","components/common/GdasApp/LeafletMap/index.tsx","hooks/leaflet.tsx","components/common/GdasApp/GeoJsonLayer/index.tsx","components/common/GdasApp/index.tsx","components/common/GdasApp/UserPosition/index.tsx","components/common/GdasApp/utils/gdas.ts","components/common/GdasApp/utils/index.ts","components/common/GdasApp/utils/leafletUtils.ts","components/App/MobileExplorer/index.tsx","components/App/index.tsx","index.tsx"],"names":["module","exports","getCurrentPid","path","window","location","pathname","includes","index","indexOf","slashIndex","slice","length","copyDeep","value","JSON","parse","stringify","DataProvider","widgetDef","setWidgetData","React","useEffect","lifecycle","dataSourcesSpec","console","debug","sources","RangeError","dataSource","checkDataSource","error","gamsDigitalObj","pid","reqUrlStart","origin","reqUrlFull","datastream","service","contentModel","fetch","then","resp","json","widgetDefCopy","data","catch","err","definedProps","Object","values","filter","val","info","WidgetDefProvider","setDefinition","undefined","children","globalPropName","objectPidRef","reqPid","requestUrl","text","e","dummyDef","name","GamsWidget","WidgetDataProvider","useState","setWidgetDef","refinedWidgetData","setRefinedWidgetData","Children","only","TypeError","cloneElement","Component","props","Overlay","content","OverlaySwitchButton","handleBtnClick","className","styles","btnHolder","btnHover","join","onClick","iconHolder","MobileOverlayLayout","overlayContent","desktopLeftcol","overlayVisible","getOverlayVisible","overlayActive","setOverlayActive","deviceWidth","setDeviceWidth","vw","Math","max","document","documentElement","clientWidth","innerWidth","overlayContainer","overlay","contr","OverlayMenu","homeLink","onSearchClick","handleOverlayVisible","onTopTileClick","overlayTopBar","href","elem","querySelector","requestFullscreen","style","background","BsCheckBox","isChecked","label","type","id","checked","BsSelect","selectMap","onChange","evt","copiedMap","keys","forEach","prop","currentTarget","key","map","selected","gamsGeoExplorerClasses","appContainer","geoControlContainer","BsTabs","tabs","headContent","tabActive","setTabActive","property","cursor","GeoDataControl","categoryLayerMap","toggleLayer","filterGroupMap","handleSetFilterGroupMap","gdasTypeMap","handleTypeSelection","dateFilterInterval","handleSetDateInterval","allAvailable","handlePublicAvailable","filterDateless","handleFilterDateless","warn","mapCopy","min","LeafletContext","createContext","LeafletMap","memo","onMapClick","config","selectedFeature","L_mapRef","useRef","initiated","setInitiated","current","L","zoomControl","setView","startView","startZoom","initMap","tileLayer","tileLayerSrc","attribution","addTo","useLeaflet","leafletProperties","refs","defaultMethods","onEachFeatureDefault","feature","layer","properties","popup","title","imageSrc","description","date","ref","bindPopup","pointToLayerDefault","latlng","circleMarker","radius","fillColor","color","weight","opacity","fillOpacity","filterDefault","testData","dummyData","on","layerRef","openPopup","Provider","features","filterTerm","geometry","coordinates","GeoJsonLayer","gdasFeatureCollection","onEachFeature","pointToLayer","useContext","L_contextProps","drawnLayer","onEachFeatureFunc","pointToLayerFunc","gdasCollection","filterFunc","produceGeoJsonMarkers","removeLayer","featureCollection","layerToDraw","geoJSON","Gdas","App","exampleFeatureCollection","Map","UserPosition","getUserLoc","locateUserSwitch","userPointLayer","accuracyLayer","onLocationFound","alert","locate","latitude","longitude","marker","circle","accuracy","addLayer","address","detailLink","osm","popupImgSrc","publicAvailable","retrieveUniquesBoolMap","propToCheck","boolMap","disperseFeatureCollection","featureCollecion","propName","uniques","collection","push","gdasUtils","common","leaflet","getL","buildFilter","conditions","filterFlag","condition","featurePropName","buildPointToLayer","functToCall","buildOnEachFeature","MobileExplorerWidget","setData","setUserPos","setLocate","categorizedCollections","setCategorizedCollections","setCategoryLayerMap","setFilterFunc","setFilterGroupMap","dateInterval","setDateInterval","setAllAvailable","filterDateLess","setFilterDateLess","setGdasTypeMap","pointToLayerFunction","geojsonMarkerOptions","curInd","xCoord","yCoord","dateCondition","featurePropVal","gdasFeature","filterDate","parseInt","dateAvailableCondition","publicAvailableCondition","filterTermCondition","filterType","allTrue","gdasTypeCondition","leafletFilterFunc","bool","category","copiedToggleLayerState","gui","geoObject","wktString","MobileExplorerGAMSWidget","MobileExplorer","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.2a470279.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"overlayContainer\":\"styles_overlayContainer__56JDe\",\"overlay\":\"styles_overlay__3OZ3X\",\"overlayActive\":\"styles_overlayActive__3Yhj5\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"btnHolder\":\"styles_btnHolder__3j3Xu\",\"btnHover\":\"styles_btnHover__3LQta\",\"iconHolder\":\"styles_iconHolder__3xEkE\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"overlayTopBar\":\"styles_overlayTopBar__1UePH\",\"overlayCard\":\"styles_overlayCard__1oUag\",\"overlayContainer\":\"styles_overlayContainer__1rJ78\"};","\r\n\r\n\r\n/**\r\n * Returns the current Digital Object's PID on GAMS\r\n * via reading out the pathname property. \r\n * @returns pid as string.\r\n */\r\nexport const getCurrentPid = (): string => {\r\n\r\n  let path = window.location.pathname;\r\n  let fedoraObjExpr = \"/archive/objects/\";\r\n\r\n  if(path.includes(fedoraObjExpr)){\r\n    let index = path.indexOf(fedoraObjExpr);\r\n    path = path.slice(index + fedoraObjExpr.length, path.length);\r\n    let slashIndex = path.indexOf(\"/\");\r\n    // pid already available \r\n    if (slashIndex === -1) return path;\r\n    return path.slice(0,slashIndex);\r\n    \r\n  //when no archive/objects before  \r\n  } else {\r\n    path = path.slice(1,path.length); //remove first '/'\r\n    let slashIndex = path.indexOf(\"/\");\r\n\r\n    // in case no further path specification\r\n    // rest params etc. would not be inside window.location.pathname.\r\n    if(slashIndex === -1) return path;\r\n    return path = path.slice(0, slashIndex);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Returns value of the 'locale' RestPathVariable. \r\n * If not set returns 'de' by default.\r\n * @param localeDefault locale value to be returned when no value is set in url.\r\n * @returns value of locale Rest variable. If not set \r\n * returns 'de' as default value. \r\n */\r\nexport const getLocale = (localeDefault: string = \"de\") => {\r\n  let locale = getRestParam(\"locale\")\r\n  return locale ? locale : localeDefault;\r\n}\r\n\r\n/**\r\n * Uses URL API to read out given RestPathVariable.\r\n * @param Name of the parameter\r\n * @returns Value of RestPathVariable. \r\n */\r\nexport const getRestParam = (paramName: string) => {\r\n  let url = new URL(window.location.href);\r\n  let params = new URLSearchParams(url.searchParams);\r\n  let param = params.get(paramName)\r\n  return param;\r\n}\r\n\r\n/**\r\n * Uses setRestParam to set 'locale' RestPathVariable to given value.\r\n * @param langVal Value 'locale' should have.\r\n */\r\nexport const setLocale = (langVal: string) => {\r\n  setRestParam(\"locale\", langVal);\r\n}\r\n\r\n/**\r\n * Sets specified RestPathVariable to given value \r\n * and sends client to the new url.\r\n * @param paramName Name of RestPathVariable to be set.\r\n * @param value New value for the RestPathVariable.\r\n */\r\nexport const setRestParam = (paramName: string, value: string): void => {\r\n  let url = new URL(window.location.href);\r\n  url.searchParams.set(paramName, value);\r\n  window.location.href = url.href;\r\n}\r\n\r\n/**\r\n * Uses JSON.parse and JSON.stringify to generate \r\n * a deep copy of given value.\r\n * @param {Object | Array<any>} value Object or Array to copy deep.\r\n * @returns {Object | Array<any>} deep copy of given Object or Array.\r\n */\r\nexport const copyDeep = (value: Object | Array<any>) => {\r\n  return JSON.parse(JSON.stringify(value));\r\n}","import React from \"react\";\r\nimport { WidgetDataProviderProps, GamsWidgetDataSource, GamsWidgetType } from \"..\";\r\nimport { getCurrentPid, copyDeep } from \"../../../../utils/gamsUtils\";\r\n\r\n\r\n/**\r\n * Handles the loading of data for a GamsWidget component \r\n * according to the abstract widget specification as JSON Schema.\r\n */\r\nconst DataProvider: React.FC<WidgetDataProviderProps> = ({ widgetDef, setWidgetData }) => {\r\n\r\n  React.useEffect(() => {\r\n    widgetDef.lifecycle = widgetDef.lifecycle ? widgetDef.lifecycle : \"develop\"; \r\n    let lifecycle = widgetDef.lifecycle;\r\n\r\n    // when no dataSpec -> assuming none necessary (e.g. data was directly written inside the data property of the widget).\r\n    //@ts-ignore\r\n    if(widgetDef.dataSourcesSpec){\r\n      //fetch data according to dataSpec\r\n      if(lifecycle === \"develop\") console.debug(\"GamsWidget-DataProvider: dataSourceSpecification provided for the widget: \", widgetDef);\r\n\r\n      //TODO -> loop over all data specs. (not only the first)\r\n      //TODO -> currently only supports json!\r\n      //atm take only first data spec into account\r\n      if(widgetDef.dataSourcesSpec.sources.length > 1)throw new RangeError(\"GamsWidget currently supports exactly one source inside the widgetDef.dataSourceSpec.sources array. Make sure to pass in the correct count.\");\r\n      let dataSource = widgetDef.dataSourcesSpec.sources[0];\r\n      if(!checkDataSource(dataSource))return console.error(\"GamsWidget-DataProvider: Validation of data source object failed. Aborting operations: \", dataSource);\r\n      \r\n      \r\n      //when dataSource is a digital object.\r\n      //following code clause build the correct \"request url\"\r\n      if(dataSource.gamsDigitalObj){\r\n\r\n        // build \"first part\" of url first according to pid definition.\r\n        let pid = dataSource.gamsDigitalObj.pid ? dataSource.gamsDigitalObj.pid : getCurrentPid();\r\n        let reqUrlStart = `${window.location.origin}/archive/objects/${pid}`;\r\n        let reqUrlFull = '';\r\n\r\n        // both defined doesn't make any sense.\r\n        if(dataSource.gamsDigitalObj.datastream && dataSource.gamsDigitalObj.service)return console.error(\"GamsWidget-DataProvider: Got a dataSource object where both a datastream and a service is defined. Please make sure to define either one: \", dataSource);\r\n\r\n        //first case of datastreams (same in every case)\r\n        if(dataSource.gamsDigitalObj.datastream){\r\n          reqUrlFull = reqUrlStart + `/datastreams/${dataSource.gamsDigitalObj.datastream}/content`;\r\n\r\n          // case of service should be called.\r\n        } else {\r\n          \r\n          // call standard service or specified one specific for content model\r\n          switch(dataSource.gamsDigitalObj.contentModel){\r\n            case \"GML\":\r\n              reqUrlFull = reqUrlStart + `/methods/sdef:GML/${dataSource.gamsDigitalObj.service ? dataSource.gamsDigitalObj.service : \"getJSON\"}`;\r\n              break;\r\n            case \"TEI\":\r\n              reqUrlFull = reqUrlStart + `/methods/sdef:TEI/${dataSource.gamsDigitalObj.service ? dataSource.gamsDigitalObj.service : \"get\"}`;\r\n              break;\r\n            case \"Context\":\r\n              reqUrlFull = reqUrlStart + `/methods/sdef:Context/${dataSource.gamsDigitalObj.service ? dataSource.gamsDigitalObj.service : \"get\"}`;\r\n              break;\r\n            case \"Query\":\r\n              reqUrlFull = reqUrlStart + `/methods/sdef:Query/${dataSource.gamsDigitalObj.service ? dataSource.gamsDigitalObj.service : \"getJSON\"}`;\r\n              break;\r\n            default:\r\n              return console.error(\"GamsWidget-DataProvider: Unsupported-ContentModel-Error at building the request url for specified content model: \", dataSource.gamsDigitalObj.contentModel, dataSource);\r\n          }\r\n\r\n        }\r\n\r\n        // when request url correctly built for gamsObject -> start fetch.\r\n        if(lifecycle === \"develop\") console.debug(\"GamsWidget-DataProvider: Sending request for widget data to the dataspecification to: \", reqUrlFull);\r\n        fetch(reqUrlFull).then(resp => {\r\n          resp.json().then(json => {\r\n            let widgetDefCopy: GamsWidgetType = copyDeep(widgetDef);\r\n            widgetDefCopy.data = json;\r\n            if(lifecycle === \"develop\") console.debug(\"GamsWidget-DataProvider: Succesfully got data - setting now data property of widget definition. Got data: \", json);\r\n            setWidgetData(widgetDefCopy);\r\n          }).catch(err => {\r\n            console.error(\"GamsWidget-DataProvider: Error parsing data as JSON from datasource: \", dataSource);\r\n            console.error(err);\r\n          });\r\n          \r\n        }).catch(err => {\r\n            console.error(\"GamsWidget-DataProvider: Error getting data from url: \", reqUrlFull);\r\n            console.error(err);\r\n        });\r\n\r\n      } \r\n\r\n\r\n\r\n    } else {\r\n      if(lifecycle === \"develop\") console.debug(\"GamsWidget-DataProvider: No dataSourceSpec provided for the widget - Assuming not needed for widget definition: \", widgetDef);\r\n      setWidgetData(copyDeep(widgetDef));\r\n    }\r\n  }, [ widgetDef, setWidgetData ]);\r\n\r\n  return null\r\n\r\n}\r\n\r\nexport default DataProvider;\r\n\r\n\r\n\r\n\r\n/**\r\n * Checks if exactly one property of given GamsWidgetDataSource object is defined.\r\n *@param dataSource GamsWidgetDataSource object to be validated. \r\n *@returns True if exactly one property is defined. False if none or multiple are defined.\r\n */\r\nconst checkDataSource = (dataSource: GamsWidgetDataSource): boolean => {\r\n  let definedProps = Object.values(dataSource).filter(val => val ? val : false);\r\n  if(definedProps.length === 1){\r\n    console.info(\"GamsWidget-DataProvider: Validation of Datasource successfull: \", dataSource);\r\n    return true;\r\n  } else if(definedProps.length === 0){\r\n    console.error(\"GamsWidget-DataProvider: All properties of given DataSource validated false. Please make sure to assign one correct property to the given datasource object: \", dataSource);\r\n    return false;\r\n  } else {\r\n    console.error(\"GamsWidget-DataProvider: More than one property is defined in given datasource. Make sure to define only one: \", dataSource);\r\n    return false;\r\n  }  \r\n}","import React from \"react\";\r\nimport { getCurrentPid } from \"../../../../utils/gamsUtils\";\r\nimport { GamsWidgetType } from \"../index\"\r\nimport { WidgetDefProviderProps } from \"..\"\r\n\r\n// Extends WidgetDefProviderProps so that additional \r\n// props can be passed down (on level of <GamsWidget/> call)\r\n// can only be optional properties.\r\ninterface GAMSWidgetDefProps extends WidgetDefProviderProps {\r\n  globalPropName?: string;\r\n  datastream?: string;\r\n  objectPidRef?: string;   // if set to undefined -> assuming current object? via datastream?\r\n                           // widget's that are configured by one specific object?\r\n                           // like a context object.  \r\n}\r\n\r\n/**\r\n * Component checks if and where the global config object was assigned and\r\n * sets state of parent component. (for the configuration / basal widget definition).\r\n * globalProp overwrites datastream -> objectPidRef overwrites default behavior of reqeuesting client's\r\n * current object's pid.\r\n * @param globalPropName Name of the property of the global window object where the widget definition could be held.\r\n * @param datastream Name of datastream where the widget definition could be.\r\n * @param objectPidRef Pid of object from where the widget definition should be requested.\r\n */\r\nconst WidgetDefProvider: React.FC<GAMSWidgetDefProps> = ({\r\n  setDefinition = undefined, \r\n  children = undefined,\r\n  globalPropName,\r\n  datastream,     \r\n  //maybe best to set object reference to \"managed content\" | \"reference\" | \"x\" ? like in cirillo?\r\n  // or contextObject with datastream?\r\n  // or service to call\r\n  objectPidRef\r\n}) => {\r\n  React.useEffect(() => {\r\n    if (!setDefinition) return;\r\n\r\n    // configured window object validates true\r\n    if(window[globalPropName as any]){\r\n      return setDefinition(window[globalPropName as any]);\r\n    } \r\n    \r\n    // window object not defined\r\n    // try to fetch for GUI def in datastream\r\n    // first assign PID.\r\n    let reqPid = objectPidRef ? objectPidRef : getCurrentPid();\r\n\r\n    if(datastream){ \r\n      let requestUrl = `${window.location.origin}/archive/objects/${reqPid}/datastreams/${datastream}/content`  \r\n      // fetch object's widget datastream\r\n      fetch(requestUrl).then(data => {\r\n        data.text().then(text => {\r\n          try {\r\n            setDefinition(JSON.parse(text));\r\n          } catch(e){\r\n            //parse xml to JSON via lib best?\r\n          }\r\n        }).catch(err => {\r\n          console.error(\"GamsWidget- WidgetDefProvider: Error stringifying the datastream at: \", requestUrl);\r\n          console.error(err);\r\n        });\r\n      }).catch(err => {\r\n        console.error(\"GamsWidget- WidgetDefProvider: Error at getting config data from url: \", requestUrl);\r\n        console.error(err);\r\n      })\r\n    } else {\r\n      console.error(\"GamsWidget- WidgetDefProvider: No global window property nor datastream defined for retrieving the widget's definition. Returning dummy-definition instead. (But the app might crash).\");\r\n      let dummyDef: GamsWidgetType  = {\r\n        name:\"Dummy-Test Widget\",\r\n        lifecycle:\"develop\"        \r\n      }\r\n      console.error(\"GamsWidget- WidgetDefProvider: Set dummy definition: \", dummyDef);\r\n      setDefinition(dummyDef);    \r\n    }\r\n\r\n  }, [setDefinition, globalPropName, datastream, objectPidRef]);\r\n\r\n  return children ? children : null;\r\n};\r\n\r\nexport default WidgetDefProvider;\r\n","import React from \"react\";\r\nimport DefaultDataProvider from \"./DataProvider\";\r\nimport DefaultWidgetDefProvider from \"./WidgetDefProvider\";\r\n\r\nexport interface GAMSWidgetProps {\r\n  widgetDef?: GamsWidgetType;\r\n}\r\n\r\n/**\r\n * Definition of props for the WidgetDefProvider.\r\n * The component must set the GamsWidget's widgetDefinition state\r\n * somehow / somewhere. (btw by default GamsWidget uses a component specific to GAMS\r\n * that can be imported from here)\r\n */\r\nexport interface WidgetDefProviderProps {\r\n  setDefinition?: React.Dispatch<\r\n    React.SetStateAction<GamsWidgetType | undefined>\r\n  >;\r\n  [property: string]: any;\r\n  children?: any;\r\n}\r\n\r\n/**\r\n * Definition of props for the WidgetDataProvider.\r\n * The component must set the GamsWidget's widgetData state\r\n * somehow / somewhere. (btw by default GamsWidget uses a component specific to GAMS\r\n * that can be imported from here)\r\n */\r\nexport interface WidgetDataProviderProps {\r\n  widgetDef: GamsWidgetType;\r\n  setWidgetData: React.Dispatch<React.SetStateAction<any>>;\r\n  children?: any;\r\n}\r\n\r\ninterface Props {\r\n  WidgetDefProvider?: {\r\n    Component: React.FC<WidgetDefProviderProps>;\r\n    props?: any;\r\n  };\r\n  WidgetDataProvider?: {\r\n    Component: React.FC<WidgetDataProviderProps>;\r\n    props?: any;\r\n  };\r\n  children: any;\r\n  globalPropName: string,\r\n  datastream: string\r\n}\r\n\r\n/**\r\n * Component provides base setup for a GAMS Widget\r\n * like configuration via ajax or local js object.\r\n * Passes configuration and data down to given child\r\n * GAMSWidgetComponent.\r\n * @param WidgetComponent WidgetComponent to be passed down.\r\n * @param WidgetDefProvider Component that handles the \"request\" / \"get\" for the Widget's configuration\r\n * @param WidgetDataProvider Component that handles the \"request\" / \"get\" for the Widget's data.\r\n */\r\nconst GamsWidget: React.FC<Props> = ({\r\n  WidgetDefProvider,\r\n  WidgetDataProvider,\r\n  globalPropName,\r\n  datastream,\r\n  children,\r\n}) => {\r\n  //initial widgetDef state -> set via Definition Provider\r\n  const [widgetDef, setWidgetDef] = React.useState<GamsWidgetType | undefined>(\r\n    undefined\r\n  );\r\n\r\n  // complete merged widget state (with data) -> set by the Data provider\r\n  const [refinedWidgetData, setRefinedWidgetData] = React.useState<\r\n    GamsWidgetType | undefined\r\n  >(undefined);\r\n\r\n  /**\r\n   * Display basic console messages when a widget-Definition\r\n   * is detected.\r\n   */\r\n  React.useEffect(() => {\r\n    //First check if exactly one children hass been passed down.\r\n    if(!React.Children.only(children))throw new TypeError(\"More ore less than one child was passed down to <GamsWidget/>. Please make sure to place exactly one component as GamsWidget component.\");\r\n    if (!widgetDef) return;\r\n\r\n    // message according to set lifecycle etc.\r\n    if (widgetDef.lifecycle) {\r\n      if (\r\n        widgetDef.lifecycle === \"develop\" ||\r\n        widgetDef.lifecycle === \"production\"\r\n      )\r\n        console.debug(\r\n          \"GamsWidget: WidgetDefinition's lifecycle was configured as:'\",\r\n          widgetDef.lifecycle,\r\n          \"' Set the lifecycle to 'deploy' if you want to remove the console messages.\"\r\n        );\r\n    } else {\r\n      console.debug(\r\n        \"GamsWidget: WidgetDefinition's lifecycle not set. Defaulting to:'develop'. Set the lifecycle to 'deploy' if you want to remove the console messages.\"\r\n      );\r\n    }\r\n  }, [widgetDef]);\r\n\r\n  return (\r\n    <>\r\n      {/**\r\n        * First, just call given component\r\n        * - the \"data\" property is undefined as long as data is not loaded.\r\n        * - enriched widget data is passed down (enriched voa WidgetDefProvider and DataProvider)\r\n        */}   \r\n        {React.cloneElement(children, { widgetDef: refinedWidgetData })}\r\n\r\n\r\n      {\r\n        /**\r\n         * 01. Render component that handles loading \r\n         * of widget base definition. Like GUI and \r\n         * general.\r\n         * - might be a custom component given as prop.\r\n         */\r\n      }\r\n      {WidgetDefProvider ? (\r\n        <WidgetDefProvider.Component\r\n          {...WidgetDefProvider.props}\r\n          globalPropName={globalPropName}\r\n          datastream={datastream}\r\n          setDefinition={setWidgetDef}\r\n        />\r\n      ) : (\r\n        <DefaultWidgetDefProvider setDefinition={setWidgetDef} globalPropName={globalPropName} datastream={datastream}/>\r\n      )}\r\n\r\n       {/**\r\n        * 02. Component for getting the widget's data \r\n        * - like a chunk of json data for rendering bar charts etc.\r\n        * - could also be a custom component.\r\n        */}\r\n      {widgetDef ? (\r\n        WidgetDataProvider ? (\r\n          <WidgetDataProvider.Component\r\n            widgetDef={widgetDef}\r\n            setWidgetData={setRefinedWidgetData}\r\n            {...WidgetDataProvider.props}\r\n          />\r\n        ) : (\r\n          <DefaultDataProvider\r\n            widgetDef={widgetDef}\r\n            setWidgetData={setRefinedWidgetData}\r\n          />\r\n        )\r\n      ) : null}\r\n\r\n       \r\n    </>\r\n  );\r\n};\r\n\r\nexport default GamsWidget;\r\n\r\n// GamsWidget Type\r\n\r\n// object of kind given to gamsJs?\r\n// e.g. like: gamsJs.inject.toggableSidebar({lifecycle: ...})  ---> widget config provided by gamsJs directly?  (as JSON?)\r\n// OR: gamsJs.inject.toggableSidebar()                         ---> widget config provided by datastream? (as e.g. XML)\r\nexport interface GamsWidgetType {\r\n  lifecycle?: \"develop\" | \"production\" | \"deploy\"; // defaults to develop --> message to set development mode!\r\n  name?: string; // method call in gamsJs specifies widget name. ()\r\n  description?: string; // description for the widget.\r\n  intent?: string; // description of the widget should've been used.\r\n  gui?: any; // configuration comes always(?) from the current pid. Must be handled in gamsJs not here specifically.\r\n\r\n  // arbitray data structure for the widget to use\r\n  // can define widget's data directly here\r\n  // the data provider will write fetched data onto here.\r\n  data?: any;\r\n\r\n  // not every widget needs data to work (labels)\r\n  // buttons etc. are nested inside \"gui\"\r\n  // allow multiple sources and therefore merging on client side\r\n  dataSourcesSpec?: {\r\n    // for flexibility reasons type is specified inside sources BUT:\r\n    // all sources must be of same type atm.\r\n    // otherwise the data merging process would be difficult.\r\n    // data needs to be guaranteed of same type -> otherwise crash!\r\n    sources: GamsWidgetDataSource[];\r\n  };\r\n}\r\n\r\nexport interface GamsWidgetDataSource {\r\n  // best default would be to call current pid and service!\r\n  // (but difficult -> cannot know current content model)\r\n  gamsDigitalObj?: {\r\n    pid?: string; // defaults undefined -> assume that current pid should be requested.\r\n    datastream?: string; // defaults undefined -> assuming service to call. (and not a datstream of the object)\r\n    service?: string; //                    -> ignored by standard\r\n    contentModel:\r\n      | \"TEI\"\r\n      | \"GML\"\r\n      | \"Query\"\r\n      | \"Context\"\r\n      | \"R\"\r\n      | \"LIDO\"\r\n      | \"Ontology\"\r\n      | \"SKOS\";\r\n  };\r\n  api?: {\r\n    url: string;\r\n  };\r\n  global?: {\r\n    propertyName?: string;\r\n  };\r\n}\r\n","import React from \"react\";\r\n\r\ninterface Props {\r\n  content?: any;\r\n}\r\n\r\nconst Overlay: React.FC<Props> = ({ content }) => {\r\n  return <div>{content}</div>;\r\n};\r\n\r\nexport default Overlay;\r\n","\r\nimport React from \"react\";\r\nimport styles from \"./styles.module.css\"\r\n\r\ninterface Props {\r\n    handleBtnClick?: () => void;\r\n}\r\n\r\n\r\nconst OverlaySwitchButton: React.FC<Props> = ({\r\n    handleBtnClick\r\n}) => {\r\n    return <div className={[styles.btnHolder, styles.btnHover].join(\" \")} onClick={handleBtnClick ? handleBtnClick : undefined}>\r\n        <div className={styles.iconHolder}><i className=\"fas fa-road\"></i></div>\r\n    </div>\r\n}\r\n\r\nexport default OverlaySwitchButton;","import React, { useState, useEffect } from \"react\";\r\nimport Overlay from \"./Overlay\";\r\nimport styles from \"./styles.module.css\";\r\nimport OverlaySwitchButton from \"./OverlaySwitchButton\";\r\n\r\ninterface Props {\r\n  children?: any;\r\n  overlayContent?: any;\r\n  desktopLeftcol: any;\r\n  overlayVisible?: boolean;\r\n  getOverlayVisible?: (overlayVisible: boolean) => void;\r\n}\r\n\r\nconst MobileOverlayLayout: React.FC<Props> = ({\r\n  children,\r\n  overlayContent,\r\n  desktopLeftcol,\r\n  overlayVisible = false,\r\n  getOverlayVisible = undefined\r\n}) => {\r\n  const [overlayActive, setOverlayActive] = useState<boolean>(overlayVisible);\r\n  const [deviceWidth, setDeviceWidth] = useState<number | undefined>(undefined);\r\n\r\n  const handleSwitchClick = () => {\r\n    let contr = !overlayActive;\r\n    setOverlayActive(contr);\r\n    if (getOverlayVisible) getOverlayVisible(contr);\r\n  };\r\n\r\n  //calculating device width on startup\r\n  useEffect(() => {\r\n    if (deviceWidth) return;\r\n    const vw = Math.max(\r\n      document.documentElement.clientWidth,\r\n      window.innerWidth || 0\r\n    );\r\n    setDeviceWidth(vw);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (overlayVisible === undefined) return;\r\n    setOverlayActive(overlayVisible);\r\n  }, [overlayVisible]);\r\n\r\n  return deviceWidth ? (\r\n    deviceWidth > 1200 ? (\r\n      <div className=\"row\">\r\n        <div className=\"col-md-3\">\r\n          {desktopLeftcol}\r\n        </div>\r\n        <div className=\"col-md-9\">\r\n          {children ? children : null}\r\n        </div>\r\n        \r\n      </div>\r\n    ) : (\r\n      <div className={styles.overlayContainer}>\r\n        <div\r\n          className={[\r\n            styles.overlay,\r\n            overlayActive ? styles.overlayActive : \"\"\r\n          ].join(\" \")}\r\n        >\r\n          <Overlay content={overlayContent}></Overlay>\r\n        </div>\r\n        <div className={styles.overlay}>\r\n          <OverlaySwitchButton\r\n            handleBtnClick={handleSwitchClick}\r\n          ></OverlaySwitchButton>\r\n        </div>\r\n        <div className={styles.overlay}>{children ? children : null}</div>\r\n      </div>\r\n    )\r\n  ) : null;\r\n};\r\n\r\nexport default MobileOverlayLayout;\r\n","import React, { Children } from \"react\";\r\nimport styles from \"./styles.module.css\";\r\nimport BsCheckBox from \"../../../common/BsCheckBox\";\r\nimport BsSelect from \"../../../common/BsSelect\";\r\n\r\ninterface Props {\r\n  homeLink: string;\r\n  onSearchClick: () => void;\r\n  onTopTileClick: () => void;\r\n  handleOverlayVisible: (bool: boolean) => void;\r\n  children?: any;\r\n}\r\n\r\nconst OverlayMenu: React.FC<Props> = ({\r\n  homeLink,\r\n  onSearchClick,\r\n  onTopTileClick,\r\n  handleOverlayVisible,\r\n  children = undefined\r\n}) => {\r\n  const searchClickClose = () => {\r\n    onSearchClick();\r\n    handleOverlayVisible(false);\r\n  };\r\n\r\n  const topTileClickClose = () => {\r\n    onTopTileClick();\r\n    handleOverlayVisible(false);\r\n  };\r\n\r\n  const toogleFullscreen = () => {\r\n    let elemId: string = \"#root\";\r\n    let elem: HTMLElement | null = document.querySelector(elemId);\r\n    if (!elem) {\r\n      console.error(`Could not select elem with id + ${elemId}.`);\r\n      return;\r\n    }\r\n    elem.requestFullscreen();\r\n    elem.style.background = \"white\";\r\n  };\r\n\r\n  return (\r\n    <div className={`${styles.overlayContainer} container-fluid`}>\r\n      <div className={`${styles.overlayTopBar} text-center overlay-menu--icon-bar`}>\r\n        <a\r\n          href={homeLink}\r\n          className=\"btn btn-light text-dark border\"\r\n        >\r\n          <i className=\"fas fa-home\"></i>\r\n        </a>\r\n        <button\r\n          className=\"btn btn-light text-dark border\"\r\n          onClick={searchClickClose}\r\n        >\r\n          <i className=\"fas fa-search-location\"></i>\r\n        </button>\r\n        <button\r\n          className=\"btn btn-light text-dark border\"\r\n        >\r\n          <i className=\"fas fa-question\"></i>\r\n        </button>\r\n        <button\r\n          className=\"btn btn-light text-dark border\"\r\n          onClick={toogleFullscreen}\r\n        >\r\n          <i className=\"fas fa-arrows-alt\"></i>\r\n        </button>\r\n      </div>\r\n\r\n      {children}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default OverlayMenu;\r\n","import React from \"react\";\r\n\r\ninterface Props {\r\n  isChecked: boolean;\r\n  label: string;\r\n  onClick: any\r\n}\r\n\r\nconst BsCheckBox: React.FC<Props> = ({ isChecked, label, onClick }) => {\r\n  return (\r\n    <div className=\"form-check\">\r\n      <input\r\n        className=\"form-check-input\"\r\n        type=\"checkbox\"\r\n        value=\"\"\r\n        id=\"defaultCheck1\"\r\n        onClick={onClick}\r\n        checked={isChecked}\r\n      />\r\n      <label className=\"form-check-label\">{label}</label>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default BsCheckBox;\r\n","import React from \"react\";\r\n\r\ninterface Props {\r\n    selectMap: {[property: string]: boolean};\r\n    onChange?: (curOptionValue: string, selectMap: {[property: string]: boolean}) => void;\r\n}\r\n\r\nconst BsSelect: React.FC<Props> = ({\r\n    selectMap,\r\n    onChange = undefined\r\n}) => {\r\n\r\n  return (\r\n    <select onChange={onChange ? (evt) => {\r\n      \r\n      let copiedMap = {...selectMap};\r\n      Object.keys(copiedMap).forEach(prop => copiedMap[prop] = true);\r\n\r\n      // if default is set to \"all\".\r\n      if(evt.currentTarget.value === \"undefined\"){ \r\n        return onChange(evt.currentTarget.value, copiedMap);\r\n      }\r\n\r\n      copiedMap[evt.currentTarget.value] = false;\r\n      onChange(evt.currentTarget.value, copiedMap);\r\n      \r\n\r\n      } : undefined} className=\"form-control\">\r\n      <option value={\"undefined\"} key={`000_BsSelect`}>{\"Alle\"}</option>  \r\n      {Object.keys(selectMap).map(key => <option selected={!selectMap[key]} value={key} key={`${key}_BsSelect`}>{key ? key : \"Leere Gruppe\"}</option>)}  \r\n    </select>\r\n  );\r\n};\r\n\r\nexport default BsSelect;\r\n","\r\nconst toolAbbr = \"gams-geo--\";\r\n\r\nexport const gamsGeoExplorerClasses = {\r\n  appContainer: `${toolAbbr}app`,\r\n  geoControlContainer: `${toolAbbr}geo-control`\r\n}\r\n\r\n","import React from \"react\";\r\n\r\ninterface Props {\r\n  tabs: {\r\n    [property: string]: any;\r\n  };\r\n  headContent?: any\r\n  children?: any\r\n}\r\n\r\nconst BsTabs: React.FC<Props> = ({ tabs, headContent, children }) => {\r\n\r\n  const [tabActive, setTabActive] = React.useState<string>(Object.keys(tabs)[0]); \r\n\r\n  return (\r\n    <>\r\n      <div className=\"bs-tabs--header\">\r\n        <ul className=\"nav nav-tabs\">\r\n          {Object.keys(tabs).map((property) => (\r\n            <li className=\"nav-item\" style={{cursor:\"pointer\"}} onClick={() => setTabActive(property)}>\r\n              <a className={`nav-link ${property === tabActive ? 'active' : ''}`}>{property}</a>\r\n            </li>\r\n          ))}\r\n\r\n          {/* <li className=\"nav-item\">\r\n        <a className=\"nav-link active\" href=\"#\">\r\n          Inhaltlich\r\n        </a>\r\n      </li> */}\r\n        </ul>\r\n        {headContent}\r\n      </div>\r\n      <div className=\"bs-tabs--content\">\r\n        {children}\r\n        {tabs[tabActive]}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default BsTabs;\r\n","import React from \"react\";\r\nimport BsCheckBox from \"../../../common/BsCheckBox\";\r\nimport BsSelect from \"../../../common/BsSelect\";\r\nimport { gamsGeoExplorerClasses } from \"../../../../@types/enums/classNames\";\r\nimport BsTabs from \"components/common/BsTabs\";\r\n\r\ninterface Props {\r\n  categoryLayerMap: { [property: string]: boolean } | undefined;\r\n  toggleLayer: (category: string) => void;\r\n\r\n  filterGroupMap: { [property: string]: boolean } | undefined;\r\n  handleSetFilterGroupMap: (copiedMap: { [property: string]: boolean }) => void;\r\n\r\n  gdasTypeMap: { [property: string]: boolean } | undefined;\r\n  handleTypeSelection: (copiedMap: { [property: string]: boolean }) => void;\r\n\r\n  // for date\r\n  dateFilterInterval: { min: number; max: number };\r\n  handleSetDateInterval: Function;\r\n\r\n  //for public available\r\n  allAvailable: boolean;\r\n  handlePublicAvailable: Function;\r\n\r\n  //filter dateless\r\n  filterDateless: boolean;\r\n  handleFilterDateless: Function;\r\n}\r\n\r\nconst GeoDataControl: React.FC<Props> = ({\r\n  categoryLayerMap = undefined,\r\n  toggleLayer,\r\n\r\n  filterGroupMap,\r\n  handleSetFilterGroupMap,\r\n\r\n  gdasTypeMap,\r\n  handleTypeSelection,\r\n\r\n  dateFilterInterval,\r\n  handleSetDateInterval,\r\n\r\n  allAvailable,\r\n  handlePublicAvailable,\r\n\r\n  filterDateless,\r\n  handleFilterDateless,\r\n}) => {\r\n  return (\r\n    <div className={gamsGeoExplorerClasses.geoControlContainer}>\r\n      <div>\r\n        <BsTabs\r\n          tabs={{\r\n            \"Inhaltlich\": (\r\n              <>\r\n                {/**\r\n           * Generating Checkboxes according to given Map.\r\n           * That allow toggling of each given layer.\r\n           */}\r\n\r\n          <p>\r\n            ...nach <b>(Ober-)Kategorie</b>\r\n          </p>\r\n          {categoryLayerMap\r\n            ? Object.keys(categoryLayerMap).map((key) => {\r\n                if (!key) {\r\n                  console.warn(\r\n                    \"Unnamed category detected in the layerCategoryMap. Make sure to assign a valid category to eact feature.category property.\"\r\n                  );\r\n                }\r\n                return (\r\n                  <BsCheckBox\r\n                    key={`${key}_button`}\r\n                    isChecked={categoryLayerMap[key]}\r\n                    label={key ? key : \"Leere Kategorie\"}\r\n                    onClick={() => toggleLayer(key)}\r\n                  ></BsCheckBox>\r\n                );\r\n              })\r\n            : undefined}\r\n\r\n          <br></br>\r\n          <p>\r\n            ...nach <b>(Unter-)Gruppe</b>:\r\n          </p>\r\n\r\n          {/**\r\n           * Generating Buttons for group filtering\r\n           */}\r\n          {filterGroupMap ? (\r\n            <BsSelect\r\n              selectMap={filterGroupMap}\r\n              onChange={(value, mapCopy) => handleSetFilterGroupMap(mapCopy)}\r\n            ></BsSelect>\r\n          ) : undefined}\r\n          <br></br>\r\n\r\n          <p>\r\n            ....nach <b>Geografie</b>:\r\n          </p>\r\n\r\n          {gdasTypeMap ? (\r\n            <BsSelect\r\n              selectMap={gdasTypeMap}\r\n              onChange={(value, mapCopy) => handleTypeSelection(mapCopy)}\r\n            ></BsSelect>\r\n          ) : null}\r\n              </>\r\n            ),\r\n            \"Zeitlich\": (\r\n              <>\r\n                {/**\r\n           * Generating Buttons for date filtering\r\n           */}\r\n          {/* <h4>Zeitliche Filterung</h4> */}\r\n          <p>...nach <b>Jahr</b>:</p>\r\n          \r\n              \r\n              <input\r\n                style={{ background: \"orange\" }}\r\n                value={dateFilterInterval.min}\r\n                onChange={(evt) =>\r\n                  handleSetDateInterval({\r\n                    min: evt.currentTarget.value,\r\n                    max: dateFilterInterval.max,\r\n                  })\r\n                }\r\n                type=\"range\"\r\n                min=\"1900\"\r\n                max=\"2100\"\r\n              />\r\n              <div>{dateFilterInterval.min}</div>\r\n\r\n              <input\r\n                value={dateFilterInterval.max}\r\n                onChange={(evt) =>\r\n                  handleSetDateInterval({\r\n                    min: dateFilterInterval.min,\r\n                    max: evt.currentTarget.value,\r\n                  })\r\n                }\r\n                type=\"range\"\r\n                min=\"1900\"\r\n                max=\"2100\"\r\n              />\r\n              <div>{dateFilterInterval.max}</div>\r\n              <br></br>\r\n              <p>...nach <b>Vollstndigkeit</b>:</p>  \r\n              <BsCheckBox\r\n                isChecked={!filterDateless}\r\n                label=\"Zeige Orte ohne Datum\"\r\n                onClick={() => handleFilterDateless(!filterDateless)}\r\n              ></BsCheckBox>\r\n          \r\n              </>\r\n            ),\r\n            \"Zugang\": (\r\n              <>\r\n                <p>...nach <b>Zugnglichkeit</b>:</p>\r\n          <button\r\n            className={`btn btn-${!allAvailable ? \"warning\" : \"light\"}`}\r\n            onClick={() => handlePublicAvailable(!allAvailable)}\r\n          >\r\n            ffentlich\r\n          </button>\r\n              </>\r\n            ),\r\n            \"Analytisch\": (\r\n              <>\r\n                \r\n              </>\r\n            ),\r\n          }}\r\n          headContent={\r\n            <>\r\n              <br></br>\r\n              <br></br>\r\n              <h3>Auswahl einschrnken</h3>\r\n            </>\r\n          }\r\n        >\r\n          \r\n        </BsTabs>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GeoDataControl;\r\n","import React, { useEffect } from \"react\";\r\nimport { useLeaflet } from \"../../../../hooks/leaflet\";\r\nimport { gdasFeature, gdasFeatureCollection } from \"../@types\";\r\nimport { Layer } from \"leaflet\";\r\nimport L from \"leaflet\"; \r\n\r\ninterface Props {\r\n  config?: {\r\n    tileLayerSrc: string;\r\n    startView?: [number, number];\r\n    startZoom?: number;\r\n    attribution?: string;\r\n  };\r\n  selectedFeature?: gdasFeature;\r\n  onMapClick?: (evt: any) => void | undefined;\r\n  children?: any;\r\n}\r\n\r\nexport interface LeafletContextType {\r\n  refs: { L: any; L_mapRef: any };\r\n  defaultMethods: {\r\n    onEachFeatureDefault: (feature: gdasFeature, layer: Layer) => void;\r\n    pointToLayerDefault: (feature: any, latlng: any) => any;\r\n    filterDefault: (feature: gdasFeature, layer: any) => any;\r\n  };\r\n  testData: gdasFeatureCollection\r\n}\r\n\r\nexport const LeafletContext = React.createContext<\r\n  LeafletContextType | undefined\r\n>(undefined);\r\n\r\n/**\r\n * Exports not only the component but leaflet's L variable (as named export) \r\n * to allow construction of markers in the GEOJSON functionalities. \r\n * \r\n * \r\n */\r\nconst LeafletMap: React.FC<Props> = React.memo(\r\n  ({ onMapClick = undefined, children = undefined, config = undefined, selectedFeature = undefined }) => {\r\n    const {L_mapRef, initiated } = useLeaflet(config);\r\n\r\n    const onEachFeatureDefault = (feature: gdasFeature, layer: Layer) => {\r\n      let prop = feature.properties;\r\n      let popup = `\r\n      <div style=\"max-width:50vw\">\r\n        <h6>${prop.title}</h6>\r\n        <hr> </hr>\r\n        ${prop.imageSrc ? `<img src=\"${prop.imageSrc}\"> </img>` : \"\"}\r\n        <p>${prop.description}</p>\r\n        <p>Datum: ${prop.date}</p>\r\n        <a href=\"${prop.ref}\">Details</a>\r\n      </div>\r\n      `;\r\n      layer.bindPopup(popup);\r\n    };\r\n    \r\n    const pointToLayerDefault = (feature: any, latlng: any): any => {\r\n      let geojsonMarkerOptions = {\r\n        radius: 6,\r\n        fillColor: \"black\",\r\n        color: \"grey\",\r\n        weight: 1,\r\n        opacity: 1,\r\n        fillOpacity: 0.5\r\n      };\r\n      return L.circleMarker(latlng, geojsonMarkerOptions);\r\n    };\r\n    \r\n    const filterDefault = (feature: gdasFeature, layer: any): any => {\r\n      return true;\r\n    }\r\n\r\n    const leafletProperties: LeafletContextType = {\r\n      refs: {\r\n        L_mapRef,\r\n        L\r\n      },\r\n      defaultMethods: {\r\n        onEachFeatureDefault,\r\n        pointToLayerDefault,\r\n        filterDefault\r\n      },\r\n      testData: dummyData\r\n    };\r\n\r\n    useEffect(() => {\r\n      if (L_mapRef.current) {\r\n        console.info(\r\n          `%cLeaflet useEffect: Map succesfully initiated.`,\r\n          \"color:green\"\r\n        );\r\n        if (onMapClick) L_mapRef.current.on(\"click\", () => onMapClick);\r\n      }\r\n    }, [onMapClick, initiated]);\r\n\r\n    /**\r\n   * Open Popup from feature when selection changed.\r\n   * So that the map is controllable from outside.\r\n   * Need to wait until markers are actually drawn onto the map\r\n   */\r\n  useEffect(() => {\r\n    if (!selectedFeature) return;\r\n    if (!selectedFeature.properties.layerRef) {\r\n      console.debug(\r\n        `No layer associated with clicked feature. ${selectedFeature}. Make Sure to associate property selectedFeature.properties.layer with the leaflet layer in the onEachFeature function.`\r\n      );\r\n      return console.debug(selectedFeature);\r\n    }\r\n    let layerRef: Layer = selectedFeature.properties.layerRef;\r\n    layerRef.openPopup();\r\n  }, [selectedFeature]);\r\n\r\n\r\n  \r\n\r\n\r\n    return (\r\n      <>\r\n        <LeafletContext.Provider value={leafletProperties}>\r\n          <div id=\"map\" className=\"leaflet-map-container\"></div>\r\n          {children && initiated ? children : undefined}\r\n        </LeafletContext.Provider>\r\n      </>\r\n    );\r\n\r\n  }\r\n);\r\n\r\nexport default LeafletMap;\r\nexport { L };\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst dummyData: gdasFeatureCollection = {\r\n  type: \"FeatureCollection\",\r\n  features: [\r\n    {\r\n      type: \"Feature\",\r\n      properties: {\r\n        title: \"Dummy Feature from Layer component 01.\",\r\n        description:\r\n          \"(Only displayed when no data was given)\",\r\n        ref: \"o.erla.sty2\",\r\n        date: \"15.02.2019\",\r\n        layer:\"test\",\r\n        filterTerm:\"politisch\",\r\n      },\r\n      geometry: {\r\n        type: \"Point\",\r\n        coordinates: [0.30468749999999, 0.908902047770255]\r\n      }\r\n    },\r\n    {\r\n      type: \"Feature\",\r\n      properties: {\r\n        title: \"Dummy Feature from Layer component 02\",\r\n        description:\r\n          \"(Only displayed when no data was given)\",\r\n        ref: \"o.erla.sty2\",\r\n        date: \"15.02.2019\",\r\n        imageSrc: \"https://picsum.photos/id/237/200/200\",\r\n        layer:\"test\",\r\n        filterTerm:\"vegan\",\r\n      },\r\n      geometry: {\r\n        type: \"Point\",\r\n        coordinates: [0.30468749999999, 2.908902047770255]\r\n      }\r\n    }\r\n  ]\r\n};","import { useEffect, useState, useRef } from \"react\";\r\nimport L from \"leaflet\";\r\n\r\ninterface config {\r\n  tileLayerSrc: string;\r\n  startView?: [number, number];\r\n  startZoom?: number;\r\n  attribution?: string;\r\n}\r\n\r\nexport const useLeaflet = (config: config | undefined = undefined): {L_mapRef: any, initiated: boolean } => {\r\n  const L_mapRef = useRef<any | undefined>(undefined);\r\n  const [initiated, setInitiated] = useState<boolean>(false);\r\n\r\n  /**\r\n   * Handles initialization of Leaflet map object.\r\n   * Sets the ref.\r\n   */\r\n  useEffect(() => {\r\n    console.info(\r\n      `%cStart initialization process of the leaflet map.`,\r\n      `color:green`\r\n    );\r\n    if (L_mapRef.current) return; //no redraw if map already initialized\r\n\r\n    let map = L\r\n      .map(\"map\", { zoomControl: false })\r\n      .setView(\r\n        config && config.startView ? config.startView : [51.505, -0.09],\r\n        config && config.startZoom ? config.startZoom : 4\r\n      );\r\n\r\n    //assign map ref\r\n    L_mapRef.current = map;\r\n    initMap(L_mapRef.current);\r\n  }, []);\r\n\r\n  const initMap = (map: any) => {\r\n    console.info(\"%cLeaflet initializing the map\", \"color: green\");\r\n    L\r\n      .tileLayer(\r\n        `${\r\n          config\r\n            ? config.tileLayerSrc\r\n            : \"https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png\"\r\n        }`,\r\n        {\r\n          attribution: `${\r\n            config && config.attribution\r\n              ? config.attribution\r\n              : '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\r\n          }`\r\n        }\r\n      )\r\n      .addTo(map);\r\n      setInitiated(true);\r\n  };\r\n\r\n  return {L_mapRef, initiated };\r\n};\r\n\r\nexport { L }","import React, { useContext, useRef, useEffect } from \"react\";\r\nimport { gdasFeature, gdasFeatureCollection } from \"../@types\";\r\nimport { Layer } from \"leaflet\";\r\nimport { LeafletContext , LeafletContextType } from \"../LeafletMap\";\r\nimport L from \"leaflet\";\r\n\r\ninterface Props {\r\n  gdasFeatureCollection: gdasFeatureCollection;\r\n  onEachFeature?: (feature: gdasFeature, layer: Layer) => void;\r\n  style?: (\r\n    feature: gdasFeature\r\n  ) => any | { color: string; weight: number; opacity: number };\r\n  pointToLayer?: (\r\n    feature: any,\r\n    latlng: any\r\n  ) => { latlng: any; geojsonMarkerOptions: Object } | undefined;\r\n  filter?: (feature: gdasFeature, layer: Layer) => any;\r\n}\r\n\r\nconst GeoJsonLayer: React.FC<Props> = ({\r\n  gdasFeatureCollection,\r\n  onEachFeature = undefined,\r\n  style,\r\n  pointToLayer = undefined,\r\n  filter\r\n}) => {\r\n  const L_mapRef = useContext<any | undefined>(LeafletContext).refs.L_mapRef;\r\n  const L_contextProps = useContext<LeafletContextType|undefined>(LeafletContext);\r\n  const drawnLayer = useRef<any>(undefined);\r\n\r\n  useEffect(() => {\r\n    if (!L_mapRef.current) return;\r\n    if (!L_contextProps)return;\r\n\r\n    //assigning props or default function/ testdata\r\n    let onEachFeatureFunc = onEachFeature ? onEachFeature : L_contextProps.defaultMethods.onEachFeatureDefault;\r\n    let pointToLayerFunc = pointToLayer ? pointToLayer : L_contextProps.defaultMethods.pointToLayerDefault;\r\n    let gdasCollection = gdasFeatureCollection;\r\n    let filterFunc = filter ? filter : L_contextProps.defaultMethods.filterDefault;\r\n\r\n    produceGeoJsonMarkers(\r\n      gdasCollection,\r\n      onEachFeatureFunc,\r\n      style,\r\n      pointToLayerFunc,\r\n      filterFunc\r\n    );\r\n  }, [gdasFeatureCollection, L_mapRef.current, filter, onEachFeature, style, pointToLayer]);\r\n\r\n  /**\r\n   * Before unmount remove the drawn layer\r\n   */\r\n  useEffect(()=>{\r\n    return () => {\r\n      if (drawnLayer.current) L_mapRef.current.removeLayer(drawnLayer.current);\r\n    }\r\n  },[])\r\n\r\n  const produceGeoJsonMarkers = (\r\n    featureCollection: gdasFeatureCollection,\r\n    onEachFeature: Function,\r\n    style: Object | undefined = undefined,\r\n    pointToLayer: Function | undefined = undefined,\r\n    filter: Function | undefined = undefined\r\n  ): void => {\r\n    //@ts-ignore\r\n    let layerToDraw = L.geoJSON(featureCollection, {\r\n      style,\r\n      //@ts-ignore\r\n      pointToLayer,\r\n      //@ts-ignore\r\n      onEachFeature: onEachFeature,\r\n      //@ts-ignore \r\n      filter\r\n    });\r\n    //draw layer here\r\n    if (drawnLayer.current) L_mapRef.current.removeLayer(drawnLayer.current);\r\n    layerToDraw.addTo(L_mapRef.current);\r\n    drawnLayer.current = layerToDraw;\r\n  };\r\n\r\n  return <></>;\r\n};\r\n\r\nexport default GeoJsonLayer;\r\n","import React from \"react\";\r\nimport LeafletMap from \"./LeafletMap\";\r\nimport GeoJsonLayer from \"./GeoJsonLayer\";\r\nimport UserPosition from \"./UserPosition\";\r\nimport { gdasFeatureCollection } from \"./@types\";\r\nimport { L } from \"./LeafletMap\";\r\n\r\ninterface Props {\r\n  children?: React.ReactComponentElement<any>;\r\n}\r\n\r\n/**\r\n *\r\n *\r\n */\r\nconst GdasApp: React.FC<Props> = ({ children }) => {\r\n  return (\r\n    <>\r\n      {children ? (\r\n        children\r\n      ) : (\r\n        <LeafletMap>\r\n          <GeoJsonLayer gdasFeatureCollection={exampleFeatureCollection}></GeoJsonLayer>\r\n          {/* <GeoJsonLayer></GeoJsonLayer> */}\r\n          {/* <UserPosition></UserPosition> */}\r\n        </LeafletMap>\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\nconst Gdas = {\r\n  App: GdasApp,\r\n  Map: LeafletMap,\r\n  GeoJsonLayer,\r\n  UserPosition\r\n}\r\n\r\nexport default Gdas;\r\nexport { L }\r\n\r\n\r\n// example feature collection \r\n// used as example data.\r\nconst exampleFeatureCollection: gdasFeatureCollection = {\r\n  type:\"FeatureCollection\",\r\n  features:[\r\n    {\r\n      type:\"Feature\",\r\n      geometry:{\r\n        type:\"Point\",\r\n        coordinates: [9.123321,10.123333],  \r\n      },\r\n      properties:{\r\n        filterTerm:\"exampleFeatureCollection_filterTerm\",\r\n        layer:\"exampleFeatureCollection_layer\",\r\n        title:\"exampleFeatureCollection_title\",\r\n        description:\"exampleFeatureCollection_desc\",\r\n        address:\"exampleFeatureCollection_gmaps\",\r\n        date:\"exampleFeatureCollection_date\",\r\n        ref:\"exampleFeatureCollection_ref\",\r\n        detailLink:\"exampleFeatureCollection_detailLink\",\r\n        osm:\"exampleFeatureCollection_osm\",\r\n        popupImgSrc:\"exampleFeatureCollection_poupImgSrc\",\r\n        publicAvailable:\"exampleFeatureCollection_publicAvailable\"\r\n      }\r\n    }\r\n  ]\r\n}","import React, { useContext, useEffect, useRef } from \"react\";\r\nimport { LeafletContext } from \"../LeafletMap\";\r\nimport L from \"leaflet\";\r\n\r\ninterface Props {\r\n  locateUserSwitch: boolean | undefined;\r\n  getUserLoc?:(geoObject: { latitude: number; longitude: number }) => void;\r\n}\r\n\r\nconst UserPosition: React.FC<Props> = ({ getUserLoc = undefined, locateUserSwitch = undefined }) => {\r\n  const L_mapRef = useContext<any | undefined>(LeafletContext).refs.L_mapRef;\r\n  const userPointLayer = useRef<any>(undefined);  \r\n  const accuracyLayer = useRef<any>(undefined); \r\n\r\n  useEffect(() => {\r\n    if(!L_mapRef.current)return;\r\n    if (getUserLoc)\r\n      L_mapRef.current\r\n        .on(\"locationfound\", (evt: any) =>\r\n          onLocationFound\r\n            ? onLocationFound(evt)\r\n            : undefined\r\n        )\r\n        .on(\"locationerror\", () => alert(\"Location access denied.\"));\r\n  }, [L_mapRef.current]);\r\n\r\n  useEffect(()=>{\r\n      if(!L_mapRef.current)return;\r\n      if(locateUserSwitch === undefined)return;\r\n      L_mapRef.current.locate();\r\n  },[locateUserSwitch])\r\n\r\n  const onLocationFound = (e: any) => {\r\n    //removes last drawn layer -> better to do in map component?\r\n    if (userPointLayer.current) {\r\n      L_mapRef.current.removeLayer(userPointLayer.current);\r\n    }\r\n    if (accuracyLayer.current) {\r\n      L_mapRef.current.removeLayer(accuracyLayer.current);\r\n    }\r\n\r\n    L_mapRef.current.setView([e.latitude, e.longitude], 14);\r\n\r\n    //generate marker\r\n    let marker = L\r\n      .marker([e.latitude, e.longitude])\r\n      .bindPopup(\"Aktuelle Position\");\r\n    let circle = L.circle([e.latitude, e.longitude], e.accuracy / 2, {\r\n      weight: 1,\r\n      color: \"blue\",\r\n      fillColor: \"#cacaca\",\r\n      fillOpacity: 0.2\r\n    });\r\n\r\n    L_mapRef.current.addLayer(marker);\r\n    userPointLayer.current = marker;\r\n    L_mapRef.current.addLayer(circle);\r\n    accuracyLayer.current = circle;\r\n    if (getUserLoc) getUserLoc(e);\r\n  };\r\n\r\n  return <></>;\r\n};\r\n\r\nexport default UserPosition;\r\n","import { gdasFeatureCollection, gdasFeature } from \"../@types\";\r\n\r\n/**\r\n * Checks for unique property values in given features (via the featureCollecion) and returns an Object\r\n * with the property values as keys set to true as value.\r\n * @param featureCollection gdasFeatureCollection that should be analyzed\r\n * @param \"name\" of the property to be extracted e.g. if feature.properties.group -> \"group\" as second argument of the function\r\n * @returns Object with all unique values as property.\r\n */\r\nexport const retrieveUniquesBoolMap = (\r\n  featureCollection: gdasFeatureCollection,\r\n  propToCheck: string\r\n): { [property: string]: boolean } => {\r\n  let boolMap: { [property: string]: boolean } = {};\r\n  featureCollection.features.forEach((feature: gdasFeature) => {\r\n    boolMap[feature.properties[propToCheck]] = true;\r\n  });\r\n  return boolMap;\r\n};\r\n\r\n\r\n/**\r\n * Breaks up given featureCollection into an array of featureCollections, where \r\n * the result is sorted according to unique values for given feature property.\r\n * E.g. all features in returned featureCollection have feature.properties.category = \"building\",\r\n * features of kind feature.properties.category = \"stone\" will be in the other collection,\r\n * if \"category\" was passed as propName.\r\n * @param featureCollecion featureCollection to break up.\r\n * @param propName propName of feature. On which unique values the break up process is based.\r\n * @returns Broke up featureCollection as array of sorted feautureCollections.\r\n */\r\nexport const disperseFeatureCollection = (featureCollecion: gdasFeatureCollection, propName: string): gdasFeatureCollection[] => {\r\n\r\n  //first retrieving unique values (for given propName) and store inside an array.\r\n  let uniques = retrieveUniquesBoolMap(featureCollecion, propName);\r\n\r\n  //second create an own feature collection for each unique prop value\r\n  let collection: gdasFeatureCollection[] = [];\r\n  Object.keys(uniques).map(key => {\r\n    let featureCollectionIntern: gdasFeatureCollection = { \r\n      type: \"FeatureCollection\",\r\n      features:[]\r\n    }\r\n    collection.push(featureCollectionIntern);\r\n  });\r\n\r\n  //third assigning features to the individual feature collections via index.\r\n  featureCollecion.features.forEach(feature => {\r\n    Object.keys(uniques).map((key,index) => {\r\n      if(feature.properties[propName] === key)collection[index].features.push(feature);\r\n    });\r\n  });\r\n\r\n  return collection;\r\n}","import { disperseFeatureCollection, retrieveUniquesBoolMap } from \"./gdas\";\r\nimport { buildFilter, buildPointToLayer, buildOnEachFeature, getL } from \"./leafletUtils\";\r\n\r\n\r\nconst gdasUtils = (() => {\r\n  return {\r\n    common: {\r\n      disperseFeatureCollection,\r\n      retrieveUniquesBoolMap\r\n    },\r\n    leaflet: {\r\n      getL,\r\n      buildFilter,\r\n      buildPointToLayer,\r\n      buildOnEachFeature\r\n    }\r\n  }\r\n\r\n})();\r\n\r\n\r\nexport default gdasUtils;","import { gdasFeature } from \"../@types\";\r\nimport L from \"leaflet\";\r\n\r\n/**\r\n * Functions generates a new filter function as Leaflet geojson filter method.\r\n * @param filterGroupMap object where the keys represent different filters. The keyValue\r\n * indicates if given feature is active or not.\r\n * @param conditions Essentially an array of filter-functions to be called.\r\n * @returns leaflet's filter function that sorts out given Object's keys if set to true.\r\n */\r\nexport const buildFilter = (\r\n  conditions?: {\r\n    featurePropName: string;\r\n    filterFunc: (\r\n      featurePropVal: any,\r\n      feature: gdasFeature\r\n    ) => false | undefined;\r\n  }[] //return false if no feature should be created on map.\r\n): ((gdasFeature: gdasFeature, layer: any) => boolean) | undefined => {\r\n  // creation of filter leaflet\r\n  let filter = (feature: gdasFeature, layer: any): boolean => {\r\n    if (!feature) return true;\r\n    if (!feature.properties) {\r\n      console.warn(\r\n        `Can't filter a feature without properties. Analyzed feature: `\r\n      );\r\n      console.warn(feature);\r\n      return true;\r\n    }\r\n\r\n    // additional conditions according to third argument\r\n    if (conditions) {\r\n      let filterFlag: boolean = false;\r\n      conditions.forEach((condition) => {\r\n        // return false if filter applies (otherwise do nothing)\r\n        if (\r\n          condition.filterFunc\r\n        ) {\r\n          let conditionFulfilled: false | undefined = condition.filterFunc(\r\n            feature.properties[condition.featurePropName],\r\n            feature\r\n          );\r\n          if (conditionFulfilled === false) {\r\n            filterFlag = true;\r\n            //return breaks loop\r\n            return;\r\n          }\r\n        }\r\n      });\r\n\r\n      // filter out via returning false.\r\n      if (filterFlag) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n  return filter;\r\n};\r\n\r\n/**\r\n * Allows to get a reference to the global Leaflet object.\r\n * @returns Reference to Leaflet global.\r\n */\r\nexport const getL = () => {\r\n  return L;\r\n}\r\n\r\n/**\r\n * Builds and returns the leaflet pointToLayerFunction, but also calls given function\r\n * where feature manipulation can take place.\r\n * This builder function will also pass in a reference to the global leaflet object L.\r\n * @param funcToCall Function to be called inside the built pointToLayerFunction. The pointToLayerFunction will be called from inside leaflet.\r\n * @returns Built pointToLayerFunction\r\n */\r\nexport const buildPointToLayer = (\r\n  functToCall: (feature: gdasFeature, latlng: any, L: any) => void\r\n): ((feature: gdasFeature, latlng: any) => any | undefined) => {\r\n  //pointToLayer Function to be returned\r\n  const pointToLayerFunction = (feature: gdasFeature, latlng: any) => {\r\n    // in the function you may manipulate the gdasFeature\r\n    return functToCall(feature, latlng, L);\r\n  };\r\n\r\n  return pointToLayerFunction;\r\n};\r\n\r\n/**\r\n * Builds and returns the leaflet onEachFeature function, but also calls given function\r\n * where own manipulation can take place. Like creating a specific popup for a given feature.\r\n * @param Function to be called inside the built onEachFeature function. The onEachFeature function will be called from inside leaflet.\r\n * @returns Built onEachFeature function.\r\n */\r\nexport const buildOnEachFeature = (\r\n  functToCall: (feature: gdasFeature, layer: any, L: any) => void\r\n): ((feature: gdasFeature, layer: any) => any | undefined) => {\r\n\r\n  const onEachFaeture = (feature: gdasFeature, layer: any) => {\r\n    return functToCall(feature, layer, L);\r\n  }\r\n\r\n  return onEachFaeture;\r\n}\r\n","import React from \"react\";\r\n\r\n// own components\r\nimport MobileOverlayLayout from \"../../common/MobileOverlayLayout\";\r\nimport OverlayMenu from \"./OverlayMenu\";\r\nimport GeoDataControl from \"./GeoDataControl\";\r\nimport { gamsGeoExplorerClasses } from \"../../../@types/enums/classNames\";\r\n\r\n/**\r\n * Defintion as GamsWidget\r\n */\r\nimport { MobileExplorerType } from \"../../../@types/gamsComponentConfig\"\r\n\r\n/*\r\n* Imports from GdasApp\r\n*/\r\nimport Gdas from \"../../common/GdasApp\"; // L = leaflet global needed for the pointToLayer functions etc.\r\nimport gdasUtils from \"../../common/GdasApp/utils\";\r\nimport {\r\n  gdasFeature,\r\n  gdasFeatureCollection,\r\n} from \"../../common/GdasApp/@types\";\r\nimport { GAMSWidgetProps } from \"components/common/GamsWidget\";\r\n\r\n\r\ninterface Props extends GAMSWidgetProps {\r\n  widgetDef?: MobileExplorerType\r\n}\r\n\r\n/**\r\n * \r\n * @param widgetDef \r\n */\r\nconst MobileExplorerWidget: React.FC<Props> = ({ widgetDef }) => {\r\n  \r\n  \r\n  // states for geo and widget data\r\n  const [data, setData] = React.useState< gdasFeatureCollection | undefined>(\r\n    widgetDef ? widgetDef.data : undefined\r\n  );\r\n\r\n\r\n  const [userPos, setUserPos] = React.useState<string | undefined>(undefined); //as WKT\r\n  const [locate, setLocate] = React.useState<boolean | undefined>(undefined);\r\n  const [overlayActive, setOverlayActive] = React.useState<boolean>(false);\r\n\r\n  // states to generate leaflet values like for filtering etc.\r\n  const [categorizedCollections, setCategorizedCollections] = React.useState<\r\n    gdasFeatureCollection[] | undefined\r\n  >(undefined);\r\n  const [categoryLayerMap, setCategoryLayerMap] = React.useState<\r\n    { [property: string]: boolean } | undefined\r\n  >(undefined);\r\n  const [filterFunc, setFilterFunc] = React.useState<\r\n    undefined | ((feature: gdasFeature, layer: any) => any)\r\n  >(undefined);\r\n  const [filterGroupMap, setFilterGroupMap] = React.useState<\r\n    { [property: string]: boolean } | undefined\r\n  >(undefined);\r\n  const [dateInterval, setDateInterval] = React.useState<{\r\n    min: number;\r\n    max: number;\r\n  }>({ min: 1900, max: 2100 });\r\n\r\n  // public Available\r\n  const [allAvailable, setAllAvailable] = React.useState<boolean>(true);\r\n\r\n  //state for filter out date vals with: \"-\"\r\n  const [filterDateLess, setFilterDateLess] = React.useState<boolean>(false);\r\n\r\n  const [gdasTypeMap, setGdasTypeMap] = React.useState< { [property: string]: boolean } | undefined>(undefined);\r\n\r\n  /**\r\n   * Useffect creates the necessary data for the component\r\n   * according to the passed down widget properties.\r\n   */\r\n  React.useEffect(() => {\r\n    if(!widgetDef)return;\r\n    if(!widgetDef.data)return;\r\n\r\n      setData(widgetDef.data);\r\n\r\n      // breaks up given feature collection in an array of featureCollections.\r\n      // break up is handled by unique \"layer\" values.\r\n      setCategorizedCollections(\r\n        gdasUtils.common.disperseFeatureCollection(widgetDef.data, \"layer\")\r\n      );\r\n\r\n      /** \r\n      generating maps that contain uniques for given feature properties \r\n      **/\r\n      // maps used in state to generate filter buttons for layer and group\r\n      // features are grouped onto <GeoJsonLayer> components\r\n      setCategoryLayerMap(\r\n        gdasUtils.common.retrieveUniquesBoolMap(widgetDef.data, \"layer\")\r\n      );\r\n\r\n      //datastructure needed to generate buttons AND the leaflet geojson filter functionality.\r\n      setFilterGroupMap(gdasUtils.common.retrieveUniquesBoolMap(widgetDef.data, \"filterTerm\"));\r\n\r\n      //datastructure needed to generate buttons AND the leaflet geojson filter functionality.\r\n      setGdasTypeMap(gdasUtils.common.retrieveUniquesBoolMap(widgetDef.data, \"type\"));\r\n\r\n  }, [widgetDef]);\r\n\r\n  const pointToLayerFunction = gdasUtils.leaflet.buildPointToLayer((feature: gdasFeature, latlng: any, L: any) => {\r\n\r\n    let geojsonMarkerOptions = {\r\n      radius: 6,\r\n      fillColor: \"#ff7800\",\r\n      color: \"grey\",\r\n      weight: 1,\r\n      opacity: 1,\r\n      fillOpacity: 0.5\r\n    };\r\n\r\n    // will set color for different layers.\r\n    if(categoryLayerMap){\r\n      let keys = Object.keys(categoryLayerMap);\r\n      let curInd = keys.indexOf(feature.properties.layer);\r\n      if(curInd !== -1){\r\n        let color = \"\";\r\n        switch(curInd){\r\n          case 0:\r\n            color = \"orange\";\r\n            break;\r\n          case 1:\r\n            color = \"tomato\";\r\n            break;\r\n          case 2:\r\n            color = \"green\";\r\n            break;\r\n          case 3: \r\n            color = \"blue\";\r\n            break;\r\n          case 4:\r\n            color =\"purple\";\r\n            break;\r\n          case 5:\r\n            color =\"white\";\r\n            break;\r\n          case 6:\r\n            color =\"yellow\";\r\n            break;\r\n          case 7:\r\n            color =\"#ccddff\";\r\n            break;\r\n          case 8:\r\n            color =\"#ffb3ff\";\r\n            break;\r\n          case 9:\r\n            color = \"#df9fbf\";\r\n            break;\r\n          case 10:\r\n            color = \"#99cc00\";\r\n            break;\r\n          default:\r\n            color= \"darkgreen\";\r\n            break;\r\n        }\r\n        geojsonMarkerOptions.fillColor = color;\r\n      }\r\n    }\r\n\r\n    \r\n\r\n    return L.circleMarker(latlng, geojsonMarkerOptions);\r\n\r\n\r\n  })\r\n\r\n\r\n  const onEachFeature = gdasUtils.leaflet.buildOnEachFeature((feature: gdasFeature, layer: any, L: any) => {\r\n\r\n    let prop = feature.properties;\r\n    //@ts-ignore\r\n    let xCoord = feature.geometry.coordinates[0];\r\n    //@ts-ignore\r\n    let yCoord = feature.geometry.coordinates[1];\r\n    let popup = `\r\n    <div style=\"max-width:50vw\">\r\n    ${prop.imageSrc ? `<img style=\"max-width:150px\" src=\"${prop.imageSrc}\"> </img>` : \"\"}\r\n      <hr> </hr>\r\n      <h6>${prop.title}</h6>\r\n      <p>Adresse: ${prop.address}</p>\r\n      <p>Typ: ${prop.type} - ${prop.publicAvailable}</p>\r\n      <a target=\"_blank\" href=\"${prop.detailLink}\">Zur Detailseite</a>\r\n      <p><a target=\"_blank\" href=\"http://maps.google.de/maps?q=${yCoord},${xCoord}&ll=${yCoord},${xCoord}&z=12\">Google Route hierhin</a></p>\r\n    </div>\r\n    `;\r\n    //http://maps.google.de/maps?q=47.503146,9.747139&ll=47.503146,9.747139&z=12\r\n    layer.bindPopup(popup);\r\n  })\r\n\r\n\r\n  const handleUserLocation = (geoObject: {\r\n    latitude: number;\r\n    longitude: number;\r\n  }) => {\r\n    let wktString = `POINT (${geoObject.latitude} ${geoObject.longitude})`;\r\n    setUserPos(wktString);\r\n  };\r\n\r\n  const handleSetFilterGroupMap = (filterVal: string): void => {\r\n    if (!filterGroupMap)\r\n      return console.error(\r\n        \"the categoryLayerMap is undefined. Cannot toggle layer therefore.\"\r\n      );\r\n    console.info(\r\n      \"%cSetting filter filterTerm to new value. Got filter value:\",\r\n      \"color: lightblue\",\r\n      filterVal\r\n    );\r\n    if (filterVal === undefined || filterVal === \"undefined\") {\r\n      let resetFilterGroupMap = { ...filterGroupMap };\r\n      Object.keys(resetFilterGroupMap).forEach(\r\n        key => (resetFilterGroupMap[key] = true)\r\n      );\r\n      setFilterGroupMap(resetFilterGroupMap);\r\n      console.info(\r\n        `%cResetting Filter group to: `,\r\n        \"color: lightblue\",\r\n        resetFilterGroupMap\r\n      );\r\n      return setFilterFunc(() => undefined);\r\n    }\r\n    // copying object avoid -> shallow vs deep copy\r\n    let copiedFilterGroupMap: { [property: string]: boolean } = {\r\n      ...filterGroupMap\r\n    };\r\n    // sets all vals to false (deactivates filter) and then only the one selected to true;\r\n    Object.keys(copiedFilterGroupMap).forEach(\r\n      key => (copiedFilterGroupMap[key] = false)\r\n    );\r\n    copiedFilterGroupMap[filterVal] = !copiedFilterGroupMap[filterVal];\r\n    console.info(\r\n      `%cApplying filter: Setting filterGroupMap now to: `,\r\n      \"color: lightblue\",\r\n      copiedFilterGroupMap\r\n    );\r\n    setFilterGroupMap(copiedFilterGroupMap);\r\n  };\r\n\r\n  /**\r\n   * Generates filter functions for each layer.\r\n   */\r\n  React.useEffect(() => {\r\n    if (!filterGroupMap) return;\r\n\r\n    // filter date across all layers\r\n    let dateCondition = {\r\n      featurePropName: \"date\",\r\n      filterFunc: (featurePropVal: any, gdasFeature: gdasFeature): false | undefined => {\r\n        //possible values for date: \"-\", YYYY, DD.MM.YYYY AND possibly \"\"\r\n        featurePropVal = featurePropVal as string;\r\n        if(!featurePropVal)return; // no filter when no date is providedd\r\n        if(featurePropVal.length === 1)return; //no filter \r\n\r\n        let filterDate: number;\r\n        if(featurePropVal.length === 4){\r\n          filterDate = parseInt(featurePropVal as string);\r\n        } else if(featurePropVal.length === 10){\r\n          filterDate = parseInt(featurePropVal.slice(6,10) as string);\r\n        } else {\r\n          console.error(\"The date value of given gdas feature is invalid. Given: \", gdasFeature);\r\n          throw new TypeError(\"The date value of given gdas feature is invalid.\");\r\n        }\r\n\r\n        let isBetween: boolean = (dateInterval.min <= filterDate) && (filterDate <= dateInterval.max);\r\n        if(!isBetween)return false; // only return if filter is applied.\r\n      }\r\n    }\r\n\r\n    // filter out values that have as date \"-\"\r\n    let dateAvailableCondition = {\r\n      featurePropName: \"date\",\r\n      filterFunc: (featurePropVal: any, gdasFeature: gdasFeature): false | undefined => {\r\n        //possible values for date: \"-\", YYYY, DD.MM.YYYY.\r\n        featurePropVal = featurePropVal as string;\r\n        // filter \r\n        if(featurePropVal === \"-\"){\r\n          if(filterDateLess)return false;\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    // filter publicAvailable across all layers.\r\n    let publicAvailableCondition = {\r\n      featurePropName: \"publicAvailable\",\r\n      filterFunc: (featurePropVal: any, gdasFeature: gdasFeature): false | undefined => {\r\n        //if all available should be displayed no filtering\r\n        if(allAvailable)return;\r\n        let isAvailable = featurePropVal === \"ffentlich zugnglich\";\r\n        if(!isAvailable)return false;  //when available filter out.\r\n      }\r\n    }\r\n\r\n    let filterTermCondition = {\r\n      featurePropName:\"filterTerm\",\r\n      filterFunc: (featurePropVal: any, gdasFeature: gdasFeature): false | undefined => {\r\n        if(!filterGroupMap)return;\r\n        if(!featurePropVal){\r\n          return undefined;\r\n        };\r\n        if(featurePropVal === \"-\")return false;\r\n        let filterType = filterGroupMap[featurePropVal];\r\n        \r\n        // filter none if all should be displayed\r\n        let allTrue = true;\r\n        Object.keys(filterGroupMap).forEach(prop => {\r\n          if(!filterGroupMap[prop]) allTrue = false;\r\n        });\r\n\r\n        if(allTrue){\r\n          //filter nothing here\r\n        } else {\r\n          if(filterType)return false;  \r\n        }\r\n      \r\n      }\r\n    }\r\n\r\n\r\n    // filter according to gdasTypeMap\r\n    let gdasTypeCondition = {\r\n      featurePropName: \"type\",\r\n      filterFunc: (featurePropVal: any, gdasFeature: gdasFeature): false | undefined => {\r\n        if(!gdasTypeMap)return;\r\n        let filterType = gdasTypeMap[featurePropVal];\r\n        \r\n        // filter none if all should be displayed\r\n        let allTrue = true;\r\n        Object.keys(gdasTypeMap).forEach(prop => {\r\n          if(!gdasTypeMap[prop]) allTrue = false;\r\n        });\r\n\r\n\r\n        if(allTrue){\r\n        } else {\r\n          // filter the one set to false\r\n          if(filterType)return false;  \r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    let leafletFilterFunc = gdasUtils.leaflet.buildFilter([publicAvailableCondition, dateCondition, dateAvailableCondition, gdasTypeCondition, filterTermCondition]);\r\n\r\n\r\n    if (leafletFilterFunc) setFilterFunc(() => leafletFilterFunc);\r\n  }, [filterGroupMap, dateInterval, allAvailable, filterDateLess, gdasTypeMap]);\r\n\r\n  const triggerLocate = () => {\r\n    if (locate === undefined) return setLocate(true);\r\n    setLocate(!locate);\r\n  };\r\n\r\n  const handleOverlayVisible = (bool: boolean) => {\r\n    setOverlayActive(bool);\r\n  };\r\n\r\n  const handleSetDateInterval = (dateInterval: {\r\n    min: string;\r\n    max: string;\r\n  }) => {\r\n    if (dateInterval.max === \"\" || dateInterval.min === \"\") return;\r\n\r\n    // min value can't be higher than max.\r\n    if(dateInterval.min > dateInterval.max){\r\n      return {\r\n        min: parseInt(dateInterval.min),\r\n        max: parseInt(dateInterval.min)\r\n      };\r\n    }\r\n\r\n    setDateInterval(() => {\r\n      return {\r\n        min: parseInt(dateInterval.min),\r\n        max: parseInt(dateInterval.max)\r\n      };\r\n    });\r\n  };\r\n\r\n  const toggleLayer = (category: string) => {\r\n    if (!categoryLayerMap)\r\n      return console.error(\r\n        \"the categoryLayerMap is undefined. Cannot toggle layer therefore.\"\r\n      );\r\n    let copiedToggleLayerState: { [property: string]: boolean } = {\r\n      ...categoryLayerMap\r\n    };\r\n    copiedToggleLayerState[category] = !categoryLayerMap[category];\r\n    setCategoryLayerMap(copiedToggleLayerState);\r\n  };\r\n\r\n  return (\r\n    <div className={gamsGeoExplorerClasses.appContainer}>\r\n      <MobileOverlayLayout\r\n        getOverlayVisible={handleOverlayVisible}\r\n        overlayVisible={overlayActive}\r\n        desktopLeftcol={\r\n          <GeoDataControl\r\n            //handles display of main layers\r\n            categoryLayerMap={categoryLayerMap}\r\n            toggleLayer={toggleLayer}\r\n            //specifies filter over given Layers.\r\n            filterGroupMap={filterGroupMap}\r\n            handleSetFilterGroupMap={(value) => setFilterGroupMap({...value})}\r\n\r\n            //type\r\n            gdasTypeMap={gdasTypeMap}\r\n            handleTypeSelection={(value) => setGdasTypeMap({...value})}\r\n\r\n            //for specifiying a data filter\r\n            dateFilterInterval={dateInterval}\r\n            handleSetDateInterval={handleSetDateInterval}\r\n            // for public available.\r\n            allAvailable={allAvailable}\r\n            handlePublicAvailable={setAllAvailable}\r\n            // controll if dateless places should be removable\r\n            filterDateless={filterDateLess}\r\n            handleFilterDateless={setFilterDateLess} \r\n          ></GeoDataControl>\r\n        }\r\n        overlayContent={\r\n          <OverlayMenu\r\n            handleOverlayVisible={handleOverlayVisible}\r\n            homeLink={\"https://gams.uni-graz.at\"}\r\n            onSearchClick={triggerLocate}\r\n            onTopTileClick={() => undefined}\r\n          >\r\n            <GeoDataControl\r\n              //handles display of main layers\r\n              categoryLayerMap={categoryLayerMap}\r\n              toggleLayer={toggleLayer}\r\n              //specifies filter over given Layers.\r\n              filterGroupMap={filterGroupMap} \r\n              handleSetFilterGroupMap={(value) => setFilterGroupMap({...value})}\r\n\r\n              //type\r\n              gdasTypeMap={gdasTypeMap}\r\n              handleTypeSelection={(value) => setGdasTypeMap({...value})}\r\n\r\n              //for specifiying a data filter\r\n              dateFilterInterval={dateInterval}\r\n              handleSetDateInterval={handleSetDateInterval}\r\n\r\n              allAvailable={allAvailable}\r\n              handlePublicAvailable={setAllAvailable}\r\n              // controll if dateless places should be removable\r\n              filterDateless={filterDateLess}\r\n              handleFilterDateless={setFilterDateLess} \r\n            ></GeoDataControl>\r\n          </OverlayMenu>\r\n        }\r\n      >\r\n        {widgetDef && data ? (\r\n          <Gdas.App>\r\n            <Gdas.Map config={widgetDef.gui}>\r\n              {categorizedCollections\r\n                ? categorizedCollections.map(featureCollection =>\r\n                    categoryLayerMap &&\r\n                    categoryLayerMap[\r\n                      featureCollection.features[0].properties.layer \r\n                    ] ? (\r\n                      <Gdas.GeoJsonLayer\r\n                        pointToLayer={pointToLayerFunction}\r\n                        gdasFeatureCollection={featureCollection}\r\n                        filter={filterFunc}\r\n                        onEachFeature={onEachFeature}\r\n                      />\r\n                    ) : (\r\n                      undefined\r\n                    )\r\n                  )\r\n                : undefined}\r\n              <Gdas.UserPosition\r\n                locateUserSwitch={locate}\r\n                getUserLoc={handleUserLocation}\r\n              ></Gdas.UserPosition>\r\n            </Gdas.Map>\r\n          </Gdas.App>\r\n        ) : null}\r\n      </MobileOverlayLayout>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MobileExplorerWidget;\r\n","import React from \"react\";\r\nimport GamsWidget from \"../common/GamsWidget\";\r\nimport MobileExplorerWidget from \"./MobileExplorer\";\r\n\r\nconst MobileExplorerGAMSWidget: React.FC = () => {\r\n  return (\r\n    <GamsWidget \r\n      globalPropName = \"GAMS_WIDGET_GDASMAPP\"\r\n      datastream = \"GAMS_WIDGET_GDASMAPP\"\r\n    >\r\n      {/* \r\n      // GamsWidget will pass down the widgetDef prop to MobileExplorerWidget!\r\n      // (So that it may not be passed here -- but is definiteley defined in MobileExplorer)\r\n      // - You have to specify exactly one widget-component.\r\n      //  */} \r\n      <MobileExplorerWidget/>\r\n    </GamsWidget>\r\n  );\r\n};\r\n\r\nexport default MobileExplorerGAMSWidget;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport MobileExplorerGAMSWidget from \"./components/App\";\r\n\r\nReactDOM.render(<MobileExplorerGAMSWidget/>, document.getElementById('GAMS_WIDGET_GDASMAPP'));"],"sourceRoot":""}